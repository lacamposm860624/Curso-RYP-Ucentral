{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# - Estructuras de datos en R-\n",
    "\n",
    "### Isaac Zainea, Daniel Montenegro & Luis Campos\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Vectores\n",
    "\n",
    "## Tipos de datos en R\n",
    "\n",
    "Un **vector** es una secuencia ordenada de datos. `R` dispone de muchos tipos de datos, por ejemplo:\n",
    "\n",
    "- `logical`: lógicos (```TRUE``` o ```FALSE```)\n",
    "- `integer`: números enteros, $\\mathbb Z$\n",
    "- `numeric`: números reales, $\\mathbb R$\n",
    "- `complex`: números complejos, $\\mathbb C$\n",
    "- `character`: palabras\n",
    "\n",
    "En los vectores de `R`, todos sus objetos han de ser del mismo tipo: todos números, todos palabras, etc. Cuando queramos usar vectores formados por objetos de diferentes tipos, tendremos que usar **listas generalizadas**, `lists` que veremos al final del tema.\n",
    "\n",
    "## Básico\n",
    "\n",
    "- ```c()```: para definir un vector\n",
    "- ```scan()```: para definir un vector\n",
    "- ```fix(x)```: para modificar visualmente el vector $x$\n",
    "- ```rep(a,n)```: para definir un vector constante que contiene el dato $a$ repetido $n$ veces\n",
    "\n",
    "```{r}\n",
    "c(1,2,3)\n",
    "rep(\"Mates\",7)\n",
    "```\n",
    "\n",
    "\n",
    "## Función scan() \n",
    "\n",
    "**Ejemplo**\n",
    "\n",
    "Vamos a crear un vector que contenga 3 copias de 1 9 9 8 0 7 2 6 con la función scan:\n",
    "<div class = \"aligncenter\">\n",
    "![](Imgs/scan.png)\n",
    "</div>\n",
    "\n",
    "\n",
    "## Básico\n",
    "\n",
    "\n",
    "**Ejercicio**\n",
    "\n",
    "1. Repite tu año de nacimiento 10 veces\n",
    "<!--rep(miAño,10)-->\n",
    "2. Crea el vector que tenga como entradas $16, 0, 1, 20, 1, 7, 88, 5, 1, 9$, llámalo vec y modifica la cuarta entrada con la función fix()\n",
    "<!--vec = c(16,0,1,20,1,7,88,5,1,9), fix(vec)-->\n",
    "<!--vec = scan(), 16 0 1 20 1 7 88 5 1 9, fix(vec)-->\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "## Progresiones y Secuencias\n",
    "\n",
    "Una progresión aritmética es una sucesión de números tales que la **diferencia**, $d$, de cualquier par de términos sucesivos de la secuencia es constante.\n",
    "$$a_n = a_1 + (n-1)\\cdot d$$\n",
    "\n",
    "- ``seq(a,b,by=d)``: para generar una [progresión aritmética](https://es.wikipedia.org/wiki/Progresión_aritmética) de diferencia $d$ que empieza en $a$ hasta llegar a $b$\n",
    "- ```seq(a,b, length.out=n)```: define progresión aritmética de longitud $n$ que va de $a$ a $b$ con diferencia $d$. Por tanto $d=(b-a)/(n-1)$\n",
    "- ```seq(a,by=d, length.out=n)```: define la progresión aritmética de longitud $n$ y diferencia $d$ que empieza en $a$\n",
    "- ```a:b```: define la secuencia de números **enteros** ($\\mathbb{Z}$) consecutivos entre dos números $a$ y $b$\n",
    "\n",
    "\n",
    "## Secuencias \n",
    "\n",
    "**Ejercicio**\n",
    "\n",
    "- Imprimir los números del 1 al 20\n",
    "<!--1:20 -->\n",
    "- Imprimir los 20 primeros números pares\n",
    "<!--seq(2,by=2, length.out=20)-->\n",
    "- Imprimid 30 números equidistantes entre el 17 y el 98, mostrando solo 4 cifras significativas\n",
    "<!--print(seq(17,98, length.out=30),4)-->\n",
    "\n",
    "<div class = \"aligncenter\">\n",
    "![](Imgs/studytime.png)\n",
    "</div>\n",
    "\n",
    "\n",
    "## Funciones\n",
    "\n",
    "Cuando queremos aplicar una función a cada uno de los elementos de un vector de datos, la función `sapply` nos ahorra tener que programar con bucles en `R`:\n",
    "\n",
    "- ```sapply(nombre_de_vector,FUN=nombre_de_función)```: para aplicar dicha función a todos los elementos del vector\n",
    "- ```sqrt(x)```: calcula un nuevo vector con las raíces cuadradas de cada uno de los elementos del vector $x$\n",
    "\n",
    "## Funciones\n",
    "\n",
    "Dado un vector de datos $x$ podemos calcular muchas medidas estadísticas acerca del mismo: \n",
    "\n",
    "- ```length(x)```: calcula la longitud del vector $x$\n",
    "- ```max(x)```: calcula el máximo del vector $x$\n",
    "- ```min(x)```: calcula el mínimo del vector $x$\n",
    "- ```sum(x)```: calcula la suma de las entradas del vector $x$\n",
    "- ```prod(x)```: calcula el producto de las entradas del vector $x$\n",
    "\n",
    "\n",
    "## Funciones\n",
    "\n",
    "- ```mean(x)```: calcula la media aritmética de las entradas del vector $x$\n",
    "- ```diff(x)```: calcula el vector formado por las diferencias sucesivas entre entradas del vector original $x$\n",
    "- ```cumsum(x)```: calcula el vector formado por las sumas acumuladas de las entradas del vector original $x$\n",
    "\t- Permite definir sucesiones descritas mediante sumatorios\n",
    "\t- Cada entrada de ``cumsum(x)`` es la suma de las entradas de $x$ hasta su posición\n",
    "\t\n",
    "\n",
    "## Funciones\n",
    "\n",
    "```{r}\n",
    "cuadrado = function(x){x^2}\n",
    "v = c(1,2,3,4,5,6)\n",
    "sapply(v, FUN = cuadrado)\n",
    "mean(v)\n",
    "cumsum(v)\n",
    "```\n",
    "\n",
    "\n",
    "## Orden\n",
    "\n",
    "- ```sort(x)```: ordena el vector en orden natural de los objetos que lo forman: el orden numérico creciente, orden alfabético...\n",
    "- ```rev(x)```: invierte el orden de los elementos del vector $x$\n",
    "\n",
    "```{r}\n",
    "v = c(1,7,5,2,4,6,3)\n",
    "sort(v)\n",
    "rev(v)\n",
    "```\n",
    "\n",
    "## Orden\n",
    "\n",
    "**Ejercicio**\n",
    "\n",
    "- Combinar las dos funciones anteriores, `sort` y `rev` para crear una función que dado un vector $x$ lo devuelva ordenado en orden decreciente.\n",
    "\n",
    "- Razonad si aplicar primero `sort` y luego `rev` a un vector $x$ daría en general el mismo resultado que aplicar primero `rev` y luego `sort`.\n",
    "\n",
    "- Investigar la documentación de la función `sort` (recordar que puedes usar la sintaxis `?sort` en la consola) para leer si cambiando algún argumento de la misma poedes obtener el mismo resultado que había programado en el primer ejercicio.\n",
    "\n",
    "## Subvectores\n",
    "\n",
    "- ```vector[i]```: da la $i$-ésima entrada del vector\n",
    "\n",
    "\t- Los índices en R empiezan en 1\n",
    "\t- ```vector[length(vector)]```: nos da la última entrada del vector\n",
    "\t- ```vector[a:b]```: si $a$ y $b$ son dos números naturales, nos da el subvector con las entradas del vector original que van de la posición $a$-ésima hasta la $b$-ésima.\n",
    "\t- ```vector[-i]```: si $i$ es un número, este subvector está formado por todas las entradas del vector original menos la entrada $i$-ésima. Si $i$ resulta ser un vector, entonces es un vector de índices y crea un nuevo vector con las entradas del vector original,cuyos índices pertenecen a $i$\n",
    "\t- ```vector[-x]```: si $x$ es un vector (de índices), entonces este es el complementario de vector[$x$]\n",
    "\t\n",
    "\n",
    "## Subvectores\n",
    "\n",
    "- También podemos utilizar operadores lógicos:\n",
    "\t\n",
    "\t- ```==```: =\n",
    "\t- ```!=```: $\\neq$\n",
    "\t- ```>=```: $\\ge$  \n",
    "\t- ```<=```: $\\le$\n",
    "\t- ```<```: $<$\n",
    "\t- ```>```: $>$\n",
    "\t- ```!```: NO lógico\n",
    "\t- ```&```: Y lógico\n",
    "\t- ```|```: O lógico\n",
    "\t\n",
    "\t\n",
    "## Subvectores\n",
    "\n",
    "```{r}\n",
    "v = c(14,5,6,19,32,0,8)\n",
    "v[2]\n",
    "v[-c(3,5)]\n",
    "v[v != 19 & v>15]\n",
    "```\n",
    "\t\n",
    "\t\n",
    "## Condicionales\n",
    "\n",
    "- ```which(x cumple condición)```: para obtener los índices de las entradas del vector $x$ que satisfacen la condición dada\n",
    "- ```which.min(x)```: nos da la primera posición en la que el vector $x$ toma su valor mínimo\n",
    "- ```which(x==min(x))```: da todas las posiciones en las que el vector $x$ toma sus valores mínimos\n",
    "- ```which.max(x)```: nos da la primera posición en la que el vector $x$ toma su valor máximo\n",
    "- ```which(x==max(x))```: da todas las posiciones en las que el vector $x$ toma sus valores máximos\n",
    "\n",
    "\n",
    "# Factores\n",
    "\n",
    "## Factor\n",
    "\n",
    "<l class=\"definition\">Factor</l>: es como un vector, pero con una estructura interna más rica que permite usarlo para clasificar observaciones\n",
    "\n",
    "- `levels`: atributo del factor. Cada elemento del factor es igual a un nivel. Los niveles clasifican las entradas del factor. Se ordenan por orden alfabético\n",
    "- Para definir un factor, primero hemos de definir un vector y trasformarlo por medio de una de las funciones `factor()` o `as.factor()`.\n",
    "\n",
    "## La función factor()\n",
    "\n",
    "- `factor(vector,levels=...)`: define un factor a partir del vector y dispone de algunos parámetros que permiten modificar el factor que se crea:\n",
    "  \n",
    "    - `levels`: permite especificar los niveles e incluso añadir niveles que no aparecen en el vector\n",
    "    - `labels`: permite cambiar los nombres de los niveles\n",
    "    \n",
    "-  `levels(factor)`: para obtener los niveles del factor\n",
    "\n",
    "\n",
    "## Factor ordenado\n",
    "\n",
    "<l class=\"definition\">Factor ordenado.</l> Es un factor donde los niveles siguen un orden\n",
    "\n",
    "- `ordered(vector,levels=...)`: función que define un factor ordenado y tiene los mismos parámetros que factor\n",
    "\n",
    "\n",
    "## Factores y factores ordenados\n",
    "\n",
    "```{r}\n",
    "fac = factor(c(1,1,1,2,2,3,2,4,1,3,3,4,2,3,4,4), \n",
    "       levels = c(1,2,3,4), labels = c(\"Sus\",\"Apr\",\"Not\",\"Exc\"))\n",
    "fac\n",
    "facOrd = ordered(c(1,1,1,2,2,3,2,4,1,3,3,4,2,3,4,4), \n",
    "       levels = c(1,2,3,4), labels = c(\"Sus\",\"Apr\",\"Not\",\"Exc\"))\n",
    "facOrd\n",
    "```\n",
    "\n",
    "\n",
    "# Lists\n",
    "\n",
    "## List\n",
    "\n",
    "<l class=\"definition\">List.</l> Lista formada por diferentes objetos, no necesariamente del mismo tipo, cada cual con un nombre interno\n",
    "\n",
    "- `list(...)`: función que crea una list\n",
    "    - Para obtener una componente concreta usamos la instrucción `list$componente`\n",
    "    - También podemos indicar el objeto por su posición usando dobles corchetes: `list[[i]]`. Lo que obtendremos es una list formada por esa única componente, no el objeto que forma la componente\n",
    "\n",
    "\n",
    "## Obtener información de una list\n",
    "\n",
    "- `str(list)`: para conocer la estructura interna de una list\n",
    "- `names(list)`: para saber los nombres de la list\n",
    "\n",
    "\n",
    "## Obtener información de una list\n",
    "\n",
    "```{r}\n",
    "x = c(1,-2,3,4,-5,6,7,-8,-9,0)\n",
    "miLista = list(nombre = \"X\", vector = x, media = mean(x), sumas = cumsum(x))\n",
    "miLista\n",
    "```\n",
    "\n",
    "\n",
    "## Obtener información de una list\n",
    "\n",
    "```{r}\n",
    "str(miLista)\n",
    "names(miLista)\n",
    "```\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# Matrices\n",
    "\n",
    "## Cómo definirlas\n",
    "\n",
    "- `matrix(vector, nrow=n, byrow=valor_lógico)`: para definir una matriz de $n$ filas formada por las entradas del vector\n",
    "    - `nrow`: número de filas\n",
    "    - `byrow`: si se iguala a TRUE, la matriz se construye por filas; si se iguala a FALSE (valor por defecto), se construye por columnas.\n",
    "    -` ncol`: número de columnas (puede usarse en lugar de nrow)\n",
    "    - R muestra las matrices indicando como [$i,$] la fila $i$-ésima y [$,j$] la columna $j$-ésima\n",
    "\t- Todas las entradas de una matriz han de ser del mismo tipo de datos\n",
    "\t\n",
    "\n",
    "## Cómo definirlas\n",
    "\n",
    "**Ejercicio**\n",
    "\n",
    "- ¿Cómo definirías una matriz constante? Es decir, ¿cómo definirías una matriz $A$ tal que $\\forall\\  i=1,...,n; j = 1,...,m$, $a_{i,j}=k$ siendo $k\\in\\mathbb{R}$? Como R no admite incógnitas, prueba para el caso específico $n = 3, m = 5, k = 0$\n",
    "<!-- matrix(0, nrow = 3, ncol = 5)-->\n",
    "\n",
    "- Con el vector vec = (1,2,3,4,5,6,7,8,9,10,11,12) crea la matriz \n",
    "$$\\begin{pmatrix}\n",
    "1 & 4 & 7 & 10\\\\\n",
    "2 & 5 & 8 & 11\\\\\n",
    "3 & 6 & 9 & 12\n",
    "\\end{pmatrix}$$\n",
    "<!--matrix(vec, ncol = 4)-->\n",
    "\n",
    "\n",
    "## Cómo construirlas\n",
    "\n",
    "- `rbind(vector1, vector2, ...)`: construye la matriz de filas vector1,  vector2,...\n",
    "- `cbind(vector1, vector2, ...)`: construye la matriz de columnas vector1,  vector2,...\n",
    "    - Los vectores han de tener la misma longitud\n",
    "    - También sirve para añadir columnas (filas) a una matriz o concatenar por columnas (filas) matrices con el mismo número de filas (columnas)\n",
    "- `diag(vector)`: para construir una matriz diagonal con un vector dado\n",
    "    - Si aplicamos diag a un número $n$, produce una matriz identidad de orden $n$\n",
    "\n",
    "\n",
    "\n",
    "## Submatrices\n",
    "\n",
    "- `matriz[i,j]`: indica la entrada ($i,j$) de la matriz, siendo $i,j\\in\\mathbb{N}$. Si $i$ y $j$ son vectores de índices, estaremos definiendo la submatriz con las filas pertenecientes al vector $i$ y columnas pertenecientes al vector $j$\n",
    "- `matriz[i,]`: indica la fila $i$-ésima de la matriz, siendo $i\\in\\mathbb{N}$\n",
    "- `matriz[,j]`: indica la columna $j$-ésima de la siendo $j\\in\\mathbb{N}$\n",
    "    - Si $i$ ($j$) es un vector de índices, estaremos definiendo la submatriz con las filas (columnas) pertenecientes al vector $i$ ($j$)\n",
    "    \n",
    "    \n",
    "## Funciones\n",
    "\n",
    "- `diag(matriz)`: para obtener la diagonal de la matriz\n",
    "- `nrow(matriz)`: nos devuelve el número de filas de la matriz\n",
    "- `ncol(matriz)`: nos devuelve el número de columnas de la matriz\n",
    "- `dim(matriz)`: nos devuelve las dimensiones de la matriz\n",
    "- `sum(matriz)`: obtenemos la suma de todas las entradas de la matriz\n",
    "- `prod(matriz)`: obtenemos el producto de todas las entradas de la matriz\n",
    "- `mean(matriz)`: obtenemos la media aritmética de todas las entradas de la matriz\n",
    "\n",
    "\n",
    "## Funciones \n",
    "\n",
    "- `colSums(matriz)`: obtenemos las sumas por columnas de la matriz\n",
    "- `rowSums(matriz)`: obtenemos las sumas por filas de la matriz\n",
    "- `colMeans(matriz)`: obtenemos las medias aritméticas por columnas de la matriz\n",
    "- `rowMeans(matriz)`: obtenemos las medias aritméticas por filas de la matriz\n",
    "\n",
    "\n",
    "## Funciones\n",
    "\n",
    "<div class=\"example\">\n",
    "**Ejemplo**\n",
    "\n",
    "Dada la matriz $$A = \\begin{pmatrix}\n",
    "1 & 4 & 7\\\\\n",
    "2 & 5 & 8\\\\\n",
    "3 & 6 & 9\n",
    "\\end{pmatrix}$$\n",
    "</div>\n",
    "\n",
    "```{r}\n",
    "A = matrix(c(1,2,3,4,5,6,7,8,9), ncol = 3)\n",
    "dim(A)\n",
    "diag(A)\n",
    "```\n",
    "\n",
    "\n",
    "## Función apply()\n",
    "\n",
    "- `apply(matriz, MARGIN=..., FUN=función)`: para aplicar otras funciones a las filas o las columnas de una matriz\n",
    "    - `MARGIN`: ha de ser 1 si queremos aplicar la función por filas; 2 si queremos aplicarla por columnas; o c(1,2) si la queremos aplicar a cada entrada\n",
    " \n",
    " \n",
    "## Función apply()\n",
    "\n",
    "```{r}\n",
    "apply(A, MARGIN = c(1,2), FUN = cuadrado)\n",
    "apply(A, MARGIN = 1, FUN = sum)\n",
    "apply(A, MARGIN = 2, FUN = sum)\n",
    "```\n",
    "\n",
    "\n",
    "## Operaciones\n",
    "\n",
    "- `t(matriz)`: para obtener la transpuesta de la matriz\n",
    "- `+`: para sumar matrices\n",
    "- `*`: para el producto de un escalar por una matriz\n",
    "- `%*%`: para multiplicar matrices\n",
    "- `mtx.exp(matriz,n)`: para elevar la matriz a $n$\n",
    "    - Del paquete `Biodem`\n",
    "\t\t- No calcula las potencias exactas, las aproxima\n",
    "- `%%`: para elevar matrices\n",
    "    - Del paquete `expm`\n",
    "\t\t- No calcula las potencias exactas, las aproxima\n",
    "\n",
    "\n",
    "## Operaciones {.exercise}\n",
    "\n",
    "**Ejercicio**\n",
    "\n",
    "Observad qué ocurre si, siendo $A = \\begin{pmatrix}\n",
    "2 & 0 & 2\\\\\n",
    "1 & 2 & 3\\\\\n",
    "0 & 1 & 3\n",
    "\\end{pmatrix}$ y $B = \\begin{pmatrix}\n",
    "3 & 2 & 1\\\\\n",
    "1 & 0 & 0\\\\\n",
    "1 & 1 & 1\n",
    "\\end{pmatrix}$, realizamos las operaciones $A*B$, $A^2$ y $B^3$\n",
    "\n",
    "<div class = \"aligncenter\">\n",
    "![](Imgs/studytime.png)\n",
    "</div>\n",
    "\n",
    "\n",
    "## Operaciones\t\t\t\n",
    "\t\t\t\n",
    "- `det(matriz)`: para calcular el determinante de la matriz\n",
    "- `qr(matriz)$rank`: para calcular el rango de la matriz\n",
    "- `solve(matriz)`: para calcular la inversa de una matriz invertible\n",
    "    - También sirve para resolver sistemas de ecuaciones lineales. Para ello introducimos `solve(matriz,b)`, donde $b$ es el vector de términos independientes\n",
    "    \n",
    "    \n",
    "## Valores y vectores propios\n",
    "\n",
    "[Vector propio y valor propio](https://es.wikipedia.org/wiki/Vector_propio_y_valor_propio)\n",
    "\n",
    "- `eigen(matriz)`: para calcular los valores (vaps) y vectores propios (veps)\n",
    "    - `eigen(matriz)$values`: nos da el vector con los vaps de la matriz en orden decreciente de su valor absoluto y repetidos tantas veces como su multiplicidad algebraica.\n",
    "    - `eigen(matriz)$vectors`: nos da una matriz cuyas columnas son los veps de la matriz.\n",
    "    \n",
    "## Valores y vectores propios\n",
    "\n",
    "```{r}\n",
    "M = rbind(c(2,6,-8), c(0,6,-3), c(0,2,1))\n",
    "eigen(M)\n",
    "```\n",
    "\n",
    "\n",
    "## Valores y vectores propios {.exercise}\n",
    "\n",
    "**Ejercicio**\n",
    "\n",
    "Comprobar, con los datos del ejemplo anterior, que si $P$ es la matriz de vectores propios de $M$ en columna y $D$ la matriz diagonal cuyas entradas son los valores propios de $M$, entoces se cumple la siguiente igualdad llamada **descomposición canónica**: $$M = P\\cdot D\\cdot P^{-1}$$\n",
    "\n",
    "<div class = \"aligncenter\">\n",
    "![](Imgs/studytime.png)\n",
    "</div>\n",
    "\n",
    "\n",
    "## Valores y vectores propios\n",
    "\n",
    "Si hay algún vap con multiplicidad algebraica mayor que 1 (es decir, que aparece más de una vez), la función `eigen()` da tantos valores de este vap como su multiplicidad algebraica indica. Además, en este caso, R intenta que los veps asociados a cada uno de estos vaps sean [linealmente independientes](https://es.wikipedia.org/wiki/Dependencia_e_independencia_lineal). Por tanto, cuando como resultado obtenemos veps repetidos asociados a un vap de multiplicidad algebraica mayor que 1, es porque para este vap no existen tantos veps linealmente independientes como su multiplicidad algebraica y, por consiguiente, la matriz no es [diagonalizable](https://es.wikipedia.org/wiki/Matriz_diagonalizable).\n",
    "\n",
    "\n",
    "## Valores y vectores propios\n",
    "\n",
    "```{r}\n",
    "M = matrix(c(0,1,0,-7,3,-1,16,-3,4), nrow=3, byrow=TRUE)\n",
    "eigen(M)\n",
    "```\n",
    "    \n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}